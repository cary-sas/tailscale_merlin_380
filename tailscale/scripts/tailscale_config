#!/bin/sh
# Merlin 380 - Tailscale controller (dbus-driven, role & SNAT aware)
# - 无参数: 按 dbus 开关应用（enable=1 => start/restart；否则 stop）
# - 子命令: start|stop|restart|status
# 状态持久化: /koolshare/configs/tailscaled.state
# 套接字:     /var/run/tailscale/tailscaled.sock
# 日志:       /tmp/tailscale_daemon.log, /tmp/tailscale_up.log
# 状态页:     /tmp/tailscale_status.txt, /tmp/tailscale_netcheck.txt
# 保险丝版改动要点：
#   1) 初次/保守运行使用 --netfilter-mode=nodivert（tailscale 不改 divert，一般规则我们自己管）
#   2) 自建 TSFWD/TSNAT（仅 IPv4）；IPv6 仅做 INPUT 放行（不建 TSFWD6、不做任何转发/NAT）
#   3) 启动后 8 秒内检测管理口可达，不通则自动回滚（撤规则+down+kill）
#   4) IPV6: 不做 NAT64/NAT66，也不做 IPv6 转发，只有 tailscale0->本机的 INPUT 放行
source /koolshare/scripts/base.sh
alias echo_date='echo 【$(TZ=UTC-8 date -R +%Y年%m月%d日\ %X)】:'

KSROOT="/koolshare"
BIN="${KSROOT}/bin"
STATE_DIR="${KSROOT}/configs/tailscale"
RUN_DIR="/var/run/tailscale"
SOCK="${RUN_DIR}/tailscaled.sock"
STATE="${STATE_DIR}/tailscaled.state"
TS="${BIN}/tailscale"
TSD="${BIN}/tailscaled"

STATUS_TXT="/tmp/tailscale_status.txt"
NETCHECK_TXT="/tmp/tailscale_netcheck.txt"
TSDLOG="/tmp/tailscale_daemon.log"
TSUPLOG="/tmp/tailscale_up.log"

need_dirs() { mkdir -p "${STATE_DIR}" "${RUN_DIR}" /tmp >/dev/null 2>&1; }

# ===== helpers: base64 与校验 =====
b64_enc() { openssl base64 -A 2>/dev/null; }                       # stdin -> base64(单行)
b64_dec() { tr -d '\r\n\t ' | openssl base64 -d -A 2>/dev/null; }  # stdin -> 解码
looks_like_tskey() { printf '%s' "$1" | grep -q '^tskey-'; }       # 明文形态校验

# 运行时安全取用（返回明文 tskey-；失败返回非0）
get_authkey_decoded() {
  local raw dec
  raw="$(dbus get tailscale_authkey 2>/dev/null | tr -d '\r\n\t ')"
  [ -z "$raw" ] && return 1

  dec="$(printf '%s' "$raw" | b64_dec || true)"
  if looks_like_tskey "$dec"; then
    printf '%s' "$dec"; return 0
  fi
  # 兼容：若 dbus 里是明文
  if looks_like_tskey "$raw"; then
    printf '%s' "$raw"; return 0
  fi
  return 1
}

# 一次性迁移：若 dbus 里是明文 tskey-，转成 base64 存回；其他情况不动
migrate_authkey_to_b64() {
  local raw dec
  raw="$(dbus get tailscale_authkey 2>/dev/null | tr -d '\r\n\t ')"
  [ -z "$raw" ] && return 0
  dec="$(printf '%s' "$raw" | b64_dec || true)"
  if looks_like_tskey "$dec"; then
    return 0  # 已是b64，不动
  elif looks_like_tskey "$raw"; then
    dbus set tailscale_authkey="$(printf '%s' "$raw" | b64_enc)"
  else
    echo_date "提示：dbus 中 tailscale_authkey 不是有效 tskey-，已忽略。"
  fi
}

# ---------- 读取 dbus（角色 / NAT 开关 等） ----------
get_conf() {
  # 读取所有 tailscale_ 前缀变量到当前环境（可能有空字符串）
  eval `dbus export tailscale`

  # 开关类：缺省=0 or 1（未设置或为空时取 0）
  tailscale_enable="${tailscale_enable:-0}"
  tailscale_ipv4_enable="${tailscale_ipv4_enable:-0}"
  tailscale_ipv6_enable="${tailscale_ipv6_enable:-0}"
  tailscale_advertise_exit="${tailscale_advertise_exit:-0}"
  tailscale_SNAT_enable="${tailscale_SNAT_enable:-1}"
  tailscale_private_enable="${tailscale_private_enable:-0}"

  # 枚举/字符串类：给出合理缺省
  tailscale_role="${tailscale_role:-1}"                  # 1=网关, 2=终端, 3=混合
  tailscale_advertise_routes="${tailscale_advertise_routes:-}"
  tailscale_login_server="${tailscale_login_server:-}"
}


# ---------- 组装 tailscale up 参数（accept-routes 由 role 推导） ----------
build_up_flags() {
  # 我们自己管防火墙
  if [ "$tailscale_role" = "1" ]; then
    UP_FLAGS="--accept-dns=false --netfilter-mode=nodivert --accept-routes=false"
  else
    UP_FLAGS="--accept-dns=false --netfilter-mode=nodivert --accept-routes=true"
  fi

  # 广播子网：网关/混合用 UI 值；终端明确清空，避免历史残留
  case "$tailscale_role" in
    1|3)
      if [ -n "$tailscale_advertise_routes" ]; then
        UP_FLAGS="$UP_FLAGS --advertise-routes=$tailscale_advertise_routes"
      fi
      ;;
    2)
      UP_FLAGS="$UP_FLAGS --advertise-routes="
      ;;
  esac

  # 出口节点（按 UI）
  [ "$tailscale_advertise_exit" = "1" ] && UP_FLAGS="$UP_FLAGS --advertise-exit-node"

  # 私有化控制平面
  if [ "$tailscale_private_enable" = "1" ] && [ -n "$tailscale_login_server" ]; then
    UP_FLAGS="$UP_FLAGS --login-server=${tailscale_login_server}"
  fi

  echo "$UP_FLAGS"
}


LAN_IF="$(nvram get lan_ifname)"
[ -z "$LAN_IF" ] && LAN_IF="br0"

TS_NET4="${TAILSCALE_NET4:-100.64.0.0/10}"   # 如需自定义，可在环境或 dbus 注入 TAILSCALE_NET4

# ---------- 流量放行 & NAT（按角色/开关应用） ----------

# ---- 仅 IPv4 NAT（与 tailscale_ipv4_enable 无关）----
enable_nat_v4() {
  # ---- 1. 建立 TSNAT 链与 POSTROUTING 跳转（幂等） ----
  iptables -t nat -N TSNAT 2>/dev/null
  iptables -t nat -C POSTROUTING -j TSNAT 2>/dev/null || iptables -t nat -A POSTROUTING -j TSNAT

  # ---- 2. 网关方向：tailnet -> LAN SNAT（仅 role=1/3 且 UI开关=1） ----
  if [ "$tailscale_SNAT_enable" = "1" ] && { [ "$tailscale_role" = "1" ] || [ "$tailscale_role" = "3" ]; }; then
    iptables -t nat -C TSNAT -s "${TS_NET4}" -o "${LAN_IF}" -j MASQUERADE 2>/dev/null || iptables -t nat -A TSNAT -s "${TS_NET4}" -o "${LAN_IF}" -j MASQUERADE
  else
    iptables -t nat -D TSNAT -s "${TS_NET4}" -o "${LAN_IF}" -j MASQUERADE 2>/dev/null
  fi

  # ---- 3. 出口方向：LAN -> tailnet MASQUERADE（role=2/3 固定开启） ----
  if [ "$tailscale_role" = "2" ] || [ "$tailscale_role" = "3" ]; then
    iptables -t nat -C TSNAT -o tailscale0 -j MASQUERADE 2>/dev/null || iptables -t nat -A TSNAT -o tailscale0 -j MASQUERADE
  else
    iptables -t nat -D TSNAT -o tailscale0 -j MASQUERADE 2>/dev/null
  fi
}


disable_nat_v4() {
  # 移除 POSTROUTING 跳转及 TSNAT 链（幂等）
  if iptables -t nat -C POSTROUTING -j TSNAT 2>/dev/null; then
    iptables -t nat -D POSTROUTING -j TSNAT 2>/dev/null
  fi
  iptables -t nat -F TSNAT 2>/dev/null
  iptables -t nat -X TSNAT 2>/dev/null

  # 兜底：清掉可能的直挂 MASQUERADE
  iptables -t nat -D POSTROUTING -s "${TS_NET4}" -o ${LAN_IF} -j MASQUERADE 2>/dev/null
  iptables -t nat -D POSTROUTING -o tailscale0 -j MASQUERADE 2>/dev/null
}

enable_forwarding_v4() {
  # 先放基础：允许 tailscale0 访问本机 + 放宽 rp_filter（避免回包被丢）
  iptables -C INPUT -i tailscale0 -j ACCEPT 2>/dev/null || iptables -I INPUT 1 -i tailscale0 -j ACCEPT
  [ -f /proc/sys/net/ipv4/conf/all/rp_filter ] && echo 2 > /proc/sys/net/ipv4/conf/all/rp_filter
  [ -f /proc/sys/net/ipv4/conf/${LAN_IF}/rp_filter ]  && echo 2 > /proc/sys/net/ipv4/conf/${LAN_IF}/rp_filter
  [ -f /proc/sys/net/ipv4/conf/tailscale0/rp_filter ] && echo 2 > /proc/sys/net/ipv4/conf/tailscale0/rp_filter

  # 若未启用 IPv4 转发功能，则只做上面的基础放行
  [ "$tailscale_ipv4_enable" = "1" ] || return 0

  case "$tailscale_role" in
    2)
      # role=2：单向出口网关（LAN 可访问 tailnet，但 tailnet 不可入 LAN）
      echo 1 > /proc/sys/net/ipv4/ip_forward

      iptables -N TSFWD 2>/dev/null
      iptables -C FORWARD -j TSFWD 2>/dev/null || iptables -A FORWARD -j TSFWD

      # 回程放行
      iptables -C TSFWD -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null\
      || iptables -A TSFWD -m state --state RELATED,ESTABLISHED -j ACCEPT
      # 仅允许 LAN -> tailscale0 新建连接
      iptables -C TSFWD -i ${LAN_IF} -o tailscale0 -j ACCEPT 2>/dev/null || iptables -A TSFWD -i ${LAN_IF} -o tailscale0 -j ACCEPT
      ;;
    1|3)
      # 网关/混合：双向互访
      echo 1 > /proc/sys/net/ipv4/ip_forward

      iptables -N TSFWD 2>/dev/null
      iptables -C FORWARD -j TSFWD 2>/dev/null || iptables -A FORWARD -j TSFWD

      iptables -C TSFWD -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null \
        || iptables -A TSFWD -m state --state RELATED,ESTABLISHED -j ACCEPT
      iptables -C TSFWD -i tailscale0 -o ${LAN_IF} -j ACCEPT 2>/dev/null || iptables -A TSFWD -i tailscale0 -o ${LAN_IF} -j ACCEPT
      iptables -C TSFWD -i ${LAN_IF} -o tailscale0 -j ACCEPT 2>/dev/null || iptables -A TSFWD -i ${LAN_IF} -o tailscale0 -j ACCEPT
      ;;
  esac
}


disable_forwarding_v4() {
  # 1) 撤 INPUT 放行（幂等删除）
  while iptables -C INPUT -i tailscale0 -j ACCEPT 2>/dev/null; do
    iptables -D INPUT -i tailscale0 -j ACCEPT
  done

  # 2) 撤 FORWARD -> TSFWD 跳转（可能存在多条，循环删）
  while iptables -C FORWARD -j TSFWD 2>/dev/null; do
    iptables -D FORWARD -j TSFWD
  done

  # 3) 清链并删除 TSFWD（若不存在会静默）
  iptables -F TSFWD 2>/dev/null
  iptables -X TSFWD 2>/dev/null
}


# ---- IPv6：仅允许 tailscale0 访问路由器本机，不做转发/NAT ----
enable_forwarding_v6() {
  # 总是允许 tailscale0 访问本机（IPv6）
  ip6tables -C INPUT -i tailscale0 -j ACCEPT 2>/dev/null || ip6tables -I INPUT 1 -i tailscale0 -j ACCEPT
  # 不做 v6 转发/NAT
  [ "$tailscale_ipv6_enable" = "1" ] || return 0
  return 0
}

disable_forwarding_v6() {
  while ip6tables -C INPUT -i tailscale0 -j ACCEPT 2>/dev/null; do
    ip6tables -D INPUT -i tailscale0 -j ACCEPT
  done
}

# 聚合调用（保持与原有函数名兼容）
enable_forwarding() {
  enable_forwarding_v4     # 受 ipv4_enable 控制
  enable_nat_v4            # 不受 ipv4_enable 控制
  enable_forwarding_v6     # 受 ipv6_enable 控制
}

disable_forwarding() {
  disable_forwarding_v4
  disable_nat_v4
  disable_forwarding_v6
}

check_binaries() {
  COMBINED="${BIN}/tailscale.combined"

  # 检查 combined 主体是否存在且可执行
  if [ ! -x "$COMBINED" ]; then
    echo_date "错误：${COMBINED} 不存在或没有可执行权限。"
    return 1
  fi

  # 检查 tailscaled / tailscale 是否为软链接且指向正确
  for link in tailscaled tailscale; do
    LINK_PATH="${BIN}/${link}"
    if [ ! -L "$LINK_PATH" ]; then
      echo_date "错误：${LINK_PATH} 不是软链接。"
      return 1
    fi
    target="$(readlink "$LINK_PATH")"
    if [ "$target" != "tailscale.combined" ]; then
      echo_date "错误：${LINK_PATH} 链接目标异常（当前指向：$target）"
      return 1
    fi
  done

  return 0
}

# ---------- 运行控制 ----------
start_ts() {
  need_dirs
  get_conf

 check_binaries || return 1

  if ! pidof tailscaled >/dev/null 2>&1; then
    echo_date "启动 tailscaled ..."
#	GOGC=20 GOMEMLIMIT=64MiB \
	TS_DEBUG_MEMORY=1 TS_LOG_TARGET=stderr \
    "${TSD}" --state="${STATE}" --statedir="${STATE_DIR}" --socket="${SOCK}" --port=41641 > "${TSDLOG}" 2>&1 &
    sleep 2
  else
    echo_date "tailscaled 已在运行"
  fi

  UP_FLAGS="$(build_up_flags)"
  echo_date "执行 tailscale up ${UP_FLAGS}"

  # 安全获取明文 tskey-；失败则不带 --authkey
  TS_UP_AUTH=""
  if _AK="$(get_authkey_decoded)"; then
    TS_UP_AUTH="--authkey=${_AK}"
  fi
  unset _AK

  if [ -n "${TS_UP_AUTH}" ]; then
    "${TS}" up ${UP_FLAGS} ${TS_UP_AUTH} > "${TSUPLOG}" 2>&1
    RET=$?
  else
    "${TS}" up ${UP_FLAGS} > "${TSUPLOG}" 2>&1
    RET=$?
  fi

  if [ $RET -ne 0 ]; then
    echo_date "tailscale up 失败（代码 $RET），查看 ${TSUPLOG}"
    return $RET
  fi

  enable_forwarding

  # ===== 保险丝：启动后 8 秒内确认管理口可达（ping 网关 IP）=====
  local GW_IP="$(nvram get lan_ipaddr 2>/dev/null)"
  ok=0
  i=0
  while [ $i -lt 4 ]; do
    ping -c1 -W2 "$GW_IP" >/dev/null 2>&1 && { ok=1; break; }
    i=$((i+1))
    sleep 2
  done
  if [ "$ok" -ne 1 ]; then
    echo_date "保险丝触发：管理口 $GW_IP 不通，回滚规则并停服务！"
    stop_ts
    return 1
  fi

  "${TS}" status > "${STATUS_TXT}" 2>&1
  echo_date "启动完成"
}

stop_ts() {
  echo_date "停止 tailscale ..."
  if [ -x "${TS}" ]; then
    "${TS}" down >/dev/null 2>&1   
  fi
  if pidof tailscaled >/dev/null 2>&1; then
    killall tailscaled >/dev/null 2>&1
    sleep 1
  fi
  disable_forwarding
  rm -f "${SOCK}"
  echo_date "已停止"
}

status_ts() {
  need_dirs
  [ -x "${TS}" ] && "${TS}" status > "${STATUS_TXT}" 2>&1 && cat "${STATUS_TXT}" || echo "tailscale 不存在：${TS}"
}

apply_ts() {
  migrate_authkey_to_b64
  get_conf
  if [ "${tailscale_enable}" = "1" ]; then
    if pidof tailscaled >/dev/null 2>&1; then
      stop_ts; start_ts
    else
      start_ts
    fi
  else
    stop_ts
  fi
}

cmd="$1"
if [ -z "$cmd" ]; then
  apply_ts
  echo "XU6J03M6"
  exit $?
fi

case "$cmd" in
  start)   start_ts ;;
  stop)    stop_ts ;;
  restart) stop_ts; start_ts ;;
  status)  status_ts ;;
  *)       apply_ts ;;
esac
echo "XU6J03M6"
exit 0
